//--- Helper functions ----------------------------------------------------------------
#include "ShaderConfig.h"

//Expand a compressed vector.
float3 expand(float3 v)
{
    return v * 2.0 - 1.0;
}

#define FADE_DEPTH -10
#define FADE_DIST 9

//--- The per-light shader ------------------------------------------------------------
void BasePerLight_vp
    (
         float4 position : POSITION,
         float2 uv : TEXCOORD0,
         float3 normal : NORMAL, 
         float3 tangent : TANGENT,

         uniform float3 eyePosition,
         uniform float4x4 worldViewProj,
         uniform float4x4 world, //world_matrix
         uniform float4x4 tvp, //texture_view_proj_matrix 0
         uniform float4 shadowDepthRange,

         uniform float4 lightPosition,
         uniform float4 spotlightDir,

         out float4 oPos : POSITION,
         out float2 oUv : TEXCOORD0,
#if (NORMAL_MAPPING && SET_NORMAL_MAPPING)
         out float3 oEyeDir : TEXCOORD1,
#else
         out float3 oNorm : TEXCOORD1,
#endif
         out float3 oLightDir : TEXCOORD2,
         out float oLightDist : TEXCOORD3,
         out float3 oHalfAngle : TEXCOORD4,
         out float3 oSpotlightDir : TEXCOORD5,
         out float4 oShadowUV : TEXCOORD6
     ) 
{
    oPos = mul(worldViewProj, position);
    oUv = uv;

    //Relative light position.
    oLightDir = lightPosition.xyz -  (position * lightPosition.w);

    //Find length (distance).
    oLightDist = length(oLightDir);

    //Normalise direction.
    oLightDir /= oLightDist;

    //The eye direction.
    float3 EyeDir = normalize(eyePosition - position.xyz);

    oSpotlightDir = mul(world, spotlightDir).xyz;

#if (NORMAL_MAPPING && SET_NORMAL_MAPPING)
    //If normal mapping is on, we move everything to tangent-space.
    float3 binormal = cross(tangent, normal);
    float3x3 rotation = float3x3(tangent, binormal, normal);

    oLightDir = mul(rotation, oLightDir);
    EyeDir = mul(rotation, EyeDir);
    oSpotlightDir = mul(rotation, oSpotlightDir);
#endif

    oHalfAngle = normalize(oLightDir + EyeDir);

#if (NORMAL_MAPPING && SET_NORMAL_MAPPING)
    oEyeDir = EyeDir;
#else
    oNorm = normal;
#endif

    //Shadow UV position
    float4 worldPos = mul(world, position);
    oShadowUV = mul(tvp, worldPos);
#if LINEAR_RANGE
    oShadowUV.z = (oShadowUV.z - shadowDepthRange.x) * shadowDepthRange.w;
#endif
}

void BasePerLight_fp
    (
         float2 uv: TEXCOORD0,
#if (NORMAL_MAPPING && SET_NORMAL_MAPPING)
         float3 eyeDir : TEXCOORD1,
#else
         float3 normal: TEXCOORD1,
#endif
         float3 LightDir: TEXCOORD2,
         float3 LightDist: TEXCOORD3,
         float3 HalfAngle: TEXCOORD4,
         float3 SpotlightDir: TEXCOORD5,
         float4 shadowUV: TEXCOORD6,

         //Material properties.
         sampler2D diffuseMap: TEXUNIT0,
         sampler2D normalBumpMap : TEXUNIT1,
#if (PARALLAX_MAPPING && SET_PARALLAX_MAPPING)
         sampler2D glowMap : TEXUNIT3,
#endif

         uniform float4 matDiffuse,
         uniform float4 matSpecular,

#if (PARALLAX_MAPPING && SET_PARALLAX_MAPPING)
         uniform float4 scaleBias,
#endif

         //Light properties.
         uniform float4 lightDiffuse,
         uniform float4 lightAtten,
         uniform float4 lightSpecular,
         uniform float4 spotlightParams,
         uniform float4 lightPosition,
         uniform float exponent,

         //Shadows
         uniform sampler2D shadowMap : TEXUNIT2,
         uniform float invSMSize,
         uniform float fixedDepthBias,
         uniform float gradientClamp,
         uniform float gradientScaleBias,
         uniform float shadowFuzzyWidth,

         out float4 oColor : COLOR
    )
{ 
#if (NORMAL_MAPPING && SET_NORMAL_MAPPING)
#if (PARALLAX_MAPPING && SET_PARALLAX_MAPPING)
    float height = tex2D(normalBumpMap, uv).a;
    float displacement = (height * scaleBias.x) - scaleBias.y;
    float3 uv2 = float3(uv, 1); 
    uv = ((eyeDir * displacement) + uv2).xy;
#endif
    //Get normal from normalmap.
    float3 N = normalize(expand(tex2D(normalBumpMap, uv).xyz));
#else
    //Use passed normal.
    float3 N = normal;
#endif

    //Calculate lighting.
    float NdotL = dot(normalize(LightDir), N);
    float NdotH = dot(normalize(HalfAngle), N);

    float4 Lit = lit(NdotL,NdotH,exponent);
    float Atten = 1 / (lightAtten.y + lightAtten.z * LightDist + lightAtten.w * LightDist * LightDist);
    oColor = (matDiffuse * lightDiffuse * Lit.y +  matSpecular * lightSpecular * Lit.z) * Atten;

    //Spotlight effect.
    if (spotlightParams[2] != 0)
    {
        float angCos = dot(normalize(-LightDir), normalize(-SpotlightDir)); //light -> object = - (object -> light)
        float i = spotlightParams[0];
        float o = spotlightParams[1];
        oColor *= smoothstep((2*o*o)-1, (2*i*i)-1, angCos);
    }

    //Diffuse texture.
    oColor *= tex2D(diffuseMap, uv);

#if (PARALLAX_MAPPING && SET_PARALLAX_MAPPING)
    oColor += tex2D(glowMap, uv);
#endif

    //Shadows

    if (lightPosition.w)
        return; //if not a directional light, no shadowing

    // point on shadowmap
#if LINEAR_RANGE
    shadowUV.xy = shadowUV.xy / shadowUV.w;
#else
    shadowUV = shadowUV / shadowUV.w;
#endif
    float4 moments = float4(0,0,0,0);
    float radius = 0.002;
    float steps = 8;
    half stepSize = 2.0 * radius / steps;
    shadowUV.xy -= radius.xx;

    for (int x = 0; x < steps; ++x)
        for (int y = 0; y < steps; ++y)
            moments +=
                tex2D(shadowMap, float2(shadowUV.xy + float2(x * stepSize, y * stepSize)));

    moments /= steps*steps;
    float litFactor = (LightDist <= moments.x ? 1 : 0);
    float E_x2 = moments.y;
    float Ex_2 = moments.x * moments.x;
    float vsmEpsilon = 0.02;
    float variance = min(max(E_x2 - Ex_2, 0.0) + vsmEpsilon, 1.0);
    float m_d = moments.x - LightDist;
    float p = variance / (variance + m_d * m_d);

    //oColor *= 0.2 + 0.8 * max(litFactor, p);
    oColor *= smoothstep(0.4, 1, max(litFactor, p));
    //if (shadowUV.z >= tex2D(shadowMap, shadowUV.xy + radius.xx).x)
        //oColor *= 0.2;
    //else
        //oColor *= smoothstep(0.4, 1, max(litFactor, p));
    //else
    //oColor *= litFactor;
    //oColor *= tex2D(shadowMap, shadowUV.xy).y;

    /*
    // gradient calculation
      float pixeloffset = invSMSize;
    float4 depths = float4(
        tex2D(shadowMap, shadowUV.xy + float2(-pixeloffset, 0)).x,
        tex2D(shadowMap, shadowUV.xy + float2(+pixeloffset, 0)).x,
        tex2D(shadowMap, shadowUV.xy + float2(0, -pixeloffset)).x,
        tex2D(shadowMap, shadowUV.xy + float2(0, +pixeloffset)).x);
 
    float2 differences = abs( depths.yw - depths.xz );
    float gradient = min(gradientClamp, max(differences.x, differences.y));
    float gradientFactor = gradient * gradientScaleBias;
 
    // visibility function
    float depthAdjust = gradientFactor + (fixedDepthBias * centerdepth);
    float finalCenterDepth = centerdepth / (steps * steps);
 
    // shadowUV.z contains lightspace position of current object
 
#if FUZZY_TEST
    // fuzzy test - introduces some ghosting in result and doesn't appear to be needed?
    oColor *= saturate(1 + (finalCenterDepth - shadowUV.z) * shadowFuzzyWidth * shadowUV.w);
#else
    // hard test
#if PCF
    // use depths from prev, calculate diff
    depths += depthAdjust.xxxx;
    float final = (finalCenterDepth > shadowUV.z) ? 1.0f : 0.0f;
    final += (depths.x > shadowUV.z) ? 1.0f : 0.0f;
    final += (depths.y > shadowUV.z) ? 1.0f : 0.0f;
    final += (depths.z > shadowUV.z) ? 1.0f : 0.0f;
    final += (depths.w > shadowUV.z) ? 1.0f : 0.0f;
 
    final *= 0.2f;
 
    oColor = float4(oColor.xyz * final, 1);
 
#else
#endif
 
#endif
    */
}

//--- The ambient one-time shader -----------------------------------------------------
void BaseAmbient_vp
   (
         float4 position : POSITION,
         float2 uv : TEXCOORD0,

         uniform float4x4 worldViewProj,
         uniform float4x4 world, //world_matrix

         uniform float3 eyePosition,

#if (PARALLAX_MAPPING && SET_PARALLAX_MAPPING)
         float3 normal : NORMAL, 
         float3 tangent : TANGENT,
         out float3 oEyeDir : TEXCOORD1,
#endif

         out float4 oPos : POSITION,
         out float2 oUv : TEXCOORD0,
         out float4 oWorldPos : TEXCOORD2
   )
{
    oPos = mul(worldViewProj, position);
    oUv = uv;

#if (PARALLAX_MAPPING && SET_PARALLAX_MAPPING)
    float3 binormal = cross(tangent, normal);
    float3x3 rotation = float3x3(tangent, binormal, normal);
    oEyeDir = normalize(eyePosition - position.xyz);
    oEyeDir = mul(rotation, oEyeDir);
#endif

    oWorldPos = mul(world, position);
}

void BaseAmbient_fp
    (
         float2 uv : TEXCOORD0,
         float4 WorldPos : TEXCOORD2,

#if (PARALLAX_MAPPING && SET_PARALLAX_MAPPING)
         float2 eyeDir : TEXCOORD1,
         uniform float4 scaleBias,
#endif

         uniform float4 matAmbient,
         uniform float4 lightAmbient,

         sampler2D diffuseMap : TEXUNIT0,
         sampler2D normalBumpMap : TEXUNIT1,
          
         out float4 oColor : COLOR
    )
{ 
#if (PARALLAX_MAPPING && SET_PARALLAX_MAPPING)
    float height = tex2D(normalBumpMap, uv).a;
    float displacement = (height * scaleBias.x) - scaleBias.y;
    float3 uv2 = float3(uv, 1); 
    uv = ((eyeDir * displacement) + uv2).xy;
#endif

    oColor = tex2D(diffuseMap, uv) * matAmbient * lightAmbient;

    //If lower, darker.
    if (WorldPos.y < FADE_DEPTH)
        oColor *= saturate((WorldPos.y -(FADE_DEPTH) + FADE_DIST) / FADE_DIST);
}


